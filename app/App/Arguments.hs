module App.Arguments
  ( execArgParser
  , handleParseResultWithSuppression
  , PrgOptions(..)
  ) where

import Control.Applicative
import Data.Version (showVersion)
import Options.Applicative
import Paths_static_ls (version)
import StaticLS.StaticEnv.Options
import System.Environment
import System.Exit
import Text.Parsec (runParser, sepEndBy, alphaNum, char)
import Text.Read

currVersion :: String
currVersion = showVersion version

data PrgOptions =
  PrgOptions
    { staticEnvOpts :: StaticEnvOptions
    , showVer :: Bool
    , showHelp :: Bool
    }
  | GHCIDOptions
    { args :: [String]
    }

-- | Run an argument parser but suppress invalid arguments (simply running the server instead)
-- Helpful for people on emacs or whose default configurations from HLS pass in
-- unsupported arguments to static-ls
execArgParser :: StaticEnvOptions -> IO (ParserResult PrgOptions)
execArgParser defaultOpts =
  execParserPure defaultPrefs (progParseInfo defaultOpts) <$> getArgs

handleParseResultWithSuppression :: StaticEnvOptions -> ParserResult PrgOptions -> IO StaticEnvOptions
handleParseResultWithSuppression defaultOpts res =  case res of
  (Success (PrgOptions {showHelp = True})) -> do
    -- Get the help text (optparse-applicative usually shows the help text on error)
    handleParseResult . Failure $
      parserFailure defaultPrefs (progParseInfo defaultOpts) (ShowHelpText Nothing) mempty
  (Success (PrgOptions {showVer = True})) -> do
    -- Show version info
    putStrLn $ "static-ls, version " <> currVersion
    exitSuccess
  (Success a) -> return a.staticEnvOpts
  -- Ignore if invalid arguments are input
  (Failure _) -> return defaultOpts
  (CompletionInvoked compl) -> do
    progn <- getProgName
    msg <- execCompletion compl progn
    putStr msg
    exitSuccess

progParseInfo :: StaticEnvOptions -> ParserInfo PrgOptions
progParseInfo defaultOpts =
  info
    (argParser defaultOpts <**> helper)
    ( fullDesc
        <> progDesc "Run static-ls as a language server for a client to talk to"
        <> header "static-ls - a lightweight language server for haskell"
    )

argParser :: StaticEnvOptions -> Parser PrgOptions
argParser defaultOpts =
  ( PrgOptions
    <$> staticEnvOptParser defaultOpts
    <*> flag
      False
      True
      ( long "version"
          <> short 'v'
          <> help "Show the program version"
      )
    <*> flag
      False
      True
      ( long "help"
          <> short 'h'
      )
  )
  <|> subparser (command "ghcid" (info (GHCIDOptions <$> many (strArgument mempty)) (progDesc "ghcid wrapper that gives static-ls extra information")))

staticEnvOptParser :: StaticEnvOptions -> Parser StaticEnvOptions
staticEnvOptParser defaultStaticEnvOptions =
  StaticEnvOptions
    <$> strOption
      ( long "hiedb"
          <> metavar "TARGET"
          <> value defaultStaticEnvOptions.optionHieDbPath
          <> help "Path to hiedb file produced by hiedb indexing hiefiles"
          <> showDefault
      )
    <*> listOption
      ( long "hiefiles"
          <> metavar "TARGET1,TARGET2,TARGET3..."
          <> value defaultStaticEnvOptions.optionHieDirs
          <> help "Path to hiefiles generated by -fwrite-ide-info and specified by -hiedir in ghc"
          <> showDefault
      )
    <*> strOption
      ( long "hifiles"
          <> metavar "TARGET"
          <> value defaultStaticEnvOptions.optionHiFilesPath
          <> help "Path to hifiles specified by -hidir in ghc"
          <> showDefault
      )
    <*> listOption
      ( long "srcDirs"
          <> metavar "TARGET1,TARGET2,TARGET3..."
          <> value defaultStaticEnvOptions.optionSrcDirs
          <> help "Path to directories containing source code. Comma delimited strings"
          <> showDefault
      )
    <*> ( flag
            defaultStaticEnvOptions.provideInlays
            False
            ( long "disableInlays"
                <> help "Explicitly disable inlay hints. (Inlays enabled by default)"
            )
        )
    <*> (maybe defaultStaticEnvOptions.inlayLengthCap id <$> Control.Applicative.optional readInlayLen)
    <*> switch (long "experimentalFeatures" <> help "Enable experimental features.")
 where
  -- Parse a list of comma delimited strings
  listOption = option $ eitherReader (either (Left . show) Right . runParser (sepEndBy (many alphaNum) (char ',')) () "")
  readInlayLen = (option ((readMaybe :: String -> Maybe Int) <$> str) $ long "maxInlayLength" <> help "Length to which inlay hints will be truncated.")
