module App.Arguments
  ( execArgParser
  , handleParseResultWithSuppression
  , PrgOptions(..)
  ) where

import Control.Applicative
import Data.Version (showVersion)
import Options.Applicative
import Paths_static_ls (version)
import StaticLS.StaticEnv.Options
import System.Environment
import System.Exit
import Text.Parsec (runParser, sepEndBy, alphaNum, char)
import Text.Read

currVersion :: String
currVersion = showVersion version

data PrgOptions =
  StaticLsOptions
    { staticEnvOpts :: StaticEnvOptions
    , showVer :: Bool
    , showHelp :: Bool
    }
  | GHCIDOptions
    { args :: [String]
    }

-- | Run an argument parser but suppress invalid arguments (simply running the server instead)
-- Helpful for people on emacs or whose default configurations from HLS pass in
-- unsupported arguments to static-ls
execArgParser :: StaticEnvOptions -> IO (ParserResult PrgOptions)
execArgParser defaultOpts =
  execParserPure defaultPrefs (progParseInfo defaultOpts) <$> getArgs

handleParseResultWithSuppression :: StaticEnvOptions -> ParserResult PrgOptions -> IO StaticEnvOptions
handleParseResultWithSuppression defaultOpts res = case res of
  Success (StaticLsOptions {showHelp = True}) -> do
    -- Get the help text (optparse-applicative usually shows the help text on error)
    handleParseResult . Failure $
      parserFailure defaultPrefs (progParseInfo defaultOpts) (ShowHelpText Nothing) mempty
  Success (StaticLsOptions {showVer = True}) -> do
    -- Show version info
    putStrLn $ "static-ls, version " <> currVersion
    exitSuccess
  Success a -> return a.staticEnvOpts
  -- Ignore if invalid arguments are input
  Failure _ -> return defaultOpts
  CompletionInvoked compl -> do
    progn <- getProgName
    msg <- execCompletion compl progn
    putStr msg
    exitSuccess

progParseInfo :: StaticEnvOptions -> ParserInfo PrgOptions
progParseInfo defaultOpts =
  info
    (argParser defaultOpts <**> helper)
    ( fullDesc
        <> progDesc "Run static-ls as a language server for a client to talk to"
        <> header "static-ls - a lightweight language server for haskell"
    )

argParser :: StaticEnvOptions -> Parser PrgOptions
argParser defaultOpts =
      staticLsParser
  <|> subparser ghcidParser
  where
  ghcidParser =  command "ghcid" $
    info
      (GHCIDOptions <$> many (strArgument mempty))
      (  progDesc "ghcid wrapper that gives static-ls extra information"
      <> footer "example: static-ls ghcid -- -c 'cabal repl foo'"
      )
  staticLsParser =
    StaticLsOptions
      <$> staticEnvOptParser defaultOpts
      <*> flag
        False
        True
        ( long "version"
            <> short 'v'
            <> help "Show the program version"
        )
      <*> flag
        False
        True
        ( long "help"
            <> short 'h'
        )

staticEnvOptParser :: StaticEnvOptions -> Parser StaticEnvOptions
staticEnvOptParser defaultStaticEnvOptions =
  StaticEnvOptions
    <$> strOption
      ( long "hiedb"
          <> metavar "TARGET"
          <> value defaultStaticEnvOptions.optionHieDbPath
          <> help "Path to hiedb file produced by hiedb indexing hiefiles"
          <> showDefault
      )
    <*> listOption
      ( long "hiefiles"
          <> metavar "TARGET1,TARGET2,TARGET3..."
          <> value defaultStaticEnvOptions.optionHieDirs
          <> help "Path to hiefiles generated by -fwrite-ide-info and specified by -hiedir in ghc"
          <> showDefault
      )
    <*> strOption
      ( long "hifiles"
          <> metavar "TARGET"
          <> value defaultStaticEnvOptions.optionHiFilesPath
          <> help "Path to hifiles specified by -hidir in ghc"
          <> showDefault
      )
    <*> listOption
      ( long "srcDirs"
          <> metavar "TARGET1,TARGET2,TARGET3..."
          <> value defaultStaticEnvOptions.optionSrcDirs
          <> help "Path to directories containing source code. Comma delimited strings"
          <> showDefault
      )
    <*> ( flag
            defaultStaticEnvOptions.provideInlays
            False
            ( long "disableInlays"
                <> help "Explicitly disable inlay hints. (Inlays enabled by default)"
            )
        )
    <*> (maybe defaultStaticEnvOptions.inlayLengthCap id <$> Control.Applicative.optional readInlayLen)
    <*> switch (long "experimentalFeatures" <> help "Enable experimental features.")
 where
  -- Parse a list of comma delimited strings
  listOption = option $ eitherReader (either (Left . show) Right . runParser (sepEndBy (many alphaNum) (char ',')) () "")
  readInlayLen = (option ((readMaybe :: String -> Maybe Int) <$> str) $ long "maxInlayLength" <> help "Length to which inlay hints will be truncated.")
