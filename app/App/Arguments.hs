module App.Arguments (execArgParser) where

import Control.Applicative
import Data.Maybe
import Data.Version (showVersion)
import Options.Applicative
import Paths_static_ls (version)
import StaticLS.StaticEnv.Options
import System.Environment
import System.Exit
import Text.Parsec hiding (many, option)
import Text.Read

currVersion :: String
currVersion = showVersion version

data PrgOptions = PrgOptions
  { staticEnvOpts :: StaticEnvOptions
  , showVer :: Bool
  , showHelp :: Bool
  }

-- | Run an argument parser but suppress invalid arguments (simply running the server instead)
-- Helpful for people on emacs or whose default configurations from HLS pass in
-- unsupported arguments to static-ls
execArgParser :: StaticEnvOptions -> IO StaticEnvOptions
execArgParser defaultOpts =
  getArgs >>= handleParseResultWithSuppression . execParserPure defaultPrefs (progParseInfo defaultOpts)
 where
  handleParseResultWithSuppression :: ParserResult PrgOptions -> IO StaticEnvOptions
  handleParseResultWithSuppression (Success (PrgOptions {showHelp = True})) =
    -- Get the help text (optparse-applicative usually shows the help text on error)
    handleParseResult . Failure $
      parserFailure defaultPrefs (progParseInfo defaultOpts) (ShowHelpText Nothing) mempty
  handleParseResultWithSuppression (Success (PrgOptions {showVer = True})) = do
    -- Show version info
    putStrLn $ "static-ls, version " <> currVersion
    exitSuccess
  handleParseResultWithSuppression (Success a) = return a.staticEnvOpts
  -- Ignore if invalid arguments are input
  handleParseResultWithSuppression (Failure _) = return defaultOpts
  handleParseResultWithSuppression (CompletionInvoked compl) = do
    progn <- getProgName
    msg <- execCompletion compl progn
    putStr msg
    exitSuccess

progParseInfo :: StaticEnvOptions -> ParserInfo PrgOptions
progParseInfo defaultOpts =
  info
    (argParser defaultOpts <**> helper)
    ( fullDesc
        <> progDesc "Run static-ls as a language server for a client to talk to"
        <> header "static-ls - a lightweight language server for haskell"
    )

argParser :: StaticEnvOptions -> Parser PrgOptions
argParser defaultOpts =
  PrgOptions
    <$> staticEnvOptParser defaultOpts
    <*> flag
      False
      True
      ( long "version"
          <> short 'v'
          <> help "Show the program version"
      )
    <*> flag
      False
      True
      ( long "help"
          <> short 'h'
      )

staticEnvOptParser :: StaticEnvOptions -> Parser StaticEnvOptions
staticEnvOptParser defaultStaticEnvOptions =
  StaticEnvOptions
    <$> strOption
      ( long "hiedb"
          <> metavar "TARGET"
          <> value defaultStaticEnvOptions.optionHieDbPath
          <> help "Path to hiedb file produced by hiedb indexing hiefiles"
          <> showDefault
      )
    <*> listOption
      ( long "hiefiles"
          <> metavar "TARGET1,TARGET2,TARGET3..."
          <> value defaultStaticEnvOptions.optionHieDirs
          <> help "Path to hiefiles generated by -fwrite-ide-info and specified by -hiedir in ghc"
          <> showDefault
      )
    <*> strOption
      ( long "hifiles"
          <> metavar "TARGET"
          <> value defaultStaticEnvOptions.optionHiFilesPath
          <> help "Path to hifiles specified by -hidir in ghc"
          <> showDefault
      )
    <*> listOption
      ( long "srcDirs"
          <> metavar "TARGET1,TARGET2,TARGET3..."
          <> value defaultStaticEnvOptions.optionSrcDirs
          <> help "Path to directories containing source code. Comma delimited strings"
          <> showDefault
      )
    <*> ( flag
            defaultStaticEnvOptions.provideInlays
            False
            ( long "disableInlays"
                <> help "Explicitly disable inlay hints. (Inlays enabled by default)"
            )
        )
    <*> (fromMaybe defaultStaticEnvOptions.inlayLengthCap <$> Control.Applicative.optional readInlayLen)
    <*> Options.Applicative.optional
      ( strOption
          ( long "fourmoluCommand"
              <> metavar "TARGET"
              <> help "Path to fourmolu binary"
              <> showDefault
          )
      )
    <*> switch (long "experimentalFeatures" <> help "Enable experimental features.")
 where
  -- Parse a list of comma delimited strings
  listOption = option $ eitherReader (either (Left . show) Right . runParser (sepEndBy (many alphaNum) (char ',')) () "")
  readInlayLen = (option ((readMaybe :: String -> Maybe Int) <$> str) $ long "maxInlayLength" <> help "Length to which inlay hints will be truncated.")
